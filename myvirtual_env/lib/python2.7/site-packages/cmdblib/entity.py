"""An ``entity`` stands for one existence of an object, like one ip address
``192.168.67.1``, one host ``xg-eoc-99``, one idc ``xg`` , etc.

An ``entity`` will have properties based on the ``fields`` property of the
schema it based on. For example, a ``test_schema`` schema have fields
properties like::

        test = client.get_schema('test')
        test_entities = client.get_entities(test)
        test.fields
        #  [Field('id', 'ID' ,'string', True, True, False, None, None), Field('multi_field', 'MF', 'long', False, False, True, None, None)]
        from cmdblib import entities
        test_entity_class = getattr(entities, 'test')

This ``test_schema_class`` will have properties ``id`` and ``multi_field``. If
the field is ``multi`` there will be corresbonding function
``append_multi_field`` and ``remove_multi_field`` to manipulate the property.

A ``EntityFactory`` will be the factory to build a new entity based on some
schema. Example::

        myTestEntity = EntityFactory(test).set_id("qwe").set_long("2345").build()

"""
import logging

from .schema import Schema
from . import entities
from . import schemas

from . import string_type

__author__ = "yuchen.huang"

LOG = logging.getLogger(__name__)

type_dict = {
    "string": string_type,
    "long": (int, ),
    "double": (float, ),
    "date": (int, )
}


def do_noting(*args, **kwargs):
    pass


def initialization_factory(fields):
    def __init__(this_entity, entity_json):
        for field in fields:
            if field.required:
                field_value = entity_json[field.name]
            else:
                field_value = entity_json.get(field.name, None)
                if field_value is None and field.multi:
                    field_value = []
            if field_value:
                pass
                # LOG.debug(field.name + ": " + str(field_value) + " " +
                # str(type(field_value)) +
                # "should be: " + str(type_dict[field.type]))
                # assert isinstance(field_value, type_dict[field.type])
            setattr(this_entity, "_" + field.name, field_value)
    return __init__


def prop_getter_factory(property_name):
    def getter(this_entity):
        return getattr(this_entity, "_" + property_name)
    return getter


def prop_setter_factory(property_name):
    def setter(this_entity, value):
        setattr(this_entity, "_" + property_name, value)
        return this_entity
    return setter


def prop_list_appender_factory(property_name):
    def appender(this_entity, value):
        setattr(this_entity, "_" + property_name,
                getattr(this_entity, "_" + property_name) + [value])
    return appender


def prop_list_remover_factory(property_name):
    def remover(this_entity, value):
        new_prop_list = getattr(this_entity, "_" + property_name).remove(value)
        setattr(this_entity, "_" + property_name, new_prop_list)
    return remover


def repr_factory(schema):
    def repr(this_entity):
        return "{entity_name}({entity_json})".format(
            entity_name="entities." + schema.name,
            entity_json=str(dict(
                (field.name, getattr(this_entity, field.name))
                for field in schema.fields)
            ))
    return repr


def to_save_format_factory(schema):
    def to_save_format(this_entity):
        return_format = {}
        for field in schema.fields:
            value = getattr(this_entity, field.name, None)
            if not value and field.multi:
                value = []
            if value is None and field.required:
                raise ValueError("{field} is required.".
                                 format(field=field.name))
            else:
                # if value:
                    # return_format[field.name] = value
                if field.multi:
                    for v in value:
                        check_instance(v, type_dict.get(field.type))
                elif field.required:
                    check_instance(value, type_dict.get(field.type))
                else:
                    check_instance(value, tuple(list(type_dict.get(field.type)) + [type(None)]))
            if value:
                return_format[field.name] = value
        return return_format
    return to_save_format


def entity_class_factory(schema, save_func=do_noting):
    """
    This is used to create an ``Entity`` class based on a ``schema``.
    The class will have properties which are define in the ``fields`` property
    of this ``schema``. If one field's ``required`` property is ``True``, the
    corresbonding value of object create by this created class can not be set
    ``None``. If one field's ``multi`` property is ``True``, the corresbonding
    value will be a list of items of type ``field.type``.

    Example::

        my_test_entity_class = entity_class_factory(my_test_schema)
        # the ``my_test_entity_class`` will be registered in ``entities`` module.

        my_new_entity = my_test_entity_class(
            {
                "id": "qwe",
                "long": "123"
            }
        )

    .. warning ::

        It's not recommended to create entity like this. If you need to create
        a new entity use the ``Client.create_entity`` method provided in
        ``cmdblib.client`` module, or the ``EntityFactory`` class below.

    """
    assert isinstance(schema, Schema)

    if entity_class_up_to_date(schema.name):
        return getattr(entities, schema.name)
    attrs = {
        "__init__": initialization_factory(schema.fields),
        "to_save_format": to_save_format_factory(schema),
        "_save": save_func,
        "__repr__": repr_factory(schema)
    }
    for field in schema.fields:
        attrs[field.name] = property(prop_getter_factory(field.name))
        attrs[field.name] = attrs[field.name].setter(
            prop_setter_factory(field.name))
        if field.multi:
            attrs["append_" + field.name] = prop_list_appender_factory(
                field.name)
            attrs["remove_" + field.name] = prop_list_remover_factory(
                field.name)
    try:
        entity_cls = type(schema.name, (EntityBase, ), attrs)
    except TypeError:
        entity_cls = type(schema.name.encode('utf-8'), (EntityBase, ), attrs)

    register(entity_cls)
    return entity_cls


class EntityBase(object):
    pass


def factory_setter_factory(property_name):
    def setter(this_entity, value):
        setattr(this_entity, property_name, value)
        return this_entity
    return setter


def factory_builder_factory(entity_cls, schema):
    def build(this_entity):
        args = {}
        for field in schema.fields:
            args[field.name] = getattr(this_entity, field.name, None)
        return entity_cls(args)
    return build


def factory_from_json_factory(entity_cls):
    def from_json(this_entity, j):
        return entity_cls(j)
    return from_json


class EntityFactory(object):
    """
    This is used to create an ``entity`` of an ``Entity`` class based on one ``schema``.
    The ``save_func`` passed is to inject the method which this entity will use to save itself.

    Example::

        my_new_entity = EntityFactory(my_test_schema, func_save_to_cmdb).set_id("qwe").set_long("123").build()
        my_new_entity.save()

    """

    def __new__(cls, schema, save_func=do_noting):
        cls.entity_class = getattr(entities, schema.name, None)
        if cls.entity_class is None:
            cls.entity_class = entity_class_factory(schema, save_func=save_func)
        attrs = {
            "_schema": schema.name
        }
        for field in schema.fields:
            attrs["set_" + field.name] = factory_setter_factory(field.name)
        attrs["build"] = factory_builder_factory(cls.entity_class, schema)
        attrs["from_json"] = factory_from_json_factory(cls.entity_class)
        try:
            return type(schema.name + "Factory", (object,), attrs)()
        except TypeError as e:
            return type(schema.name.encode('utf-8') + "Factory",
                        (object,), attrs)()


def register(cls):
    schema_cache_node = schemas.schema_cache.get(cls.__name__)
    if not entity_class_up_to_date(cls.__name__):
        setattr(entities, cls.__name__, cls)
        entities.entities[cls.__name__] = {
            "timestamp": schema_cache_node["timestamp"]
        }
        return cls
    else:
        return getattr(entities, cls.__name__)


def entity_class_up_to_date(entity_class_name):
    schema_cache_node = schemas.schema_cache.get(entity_class_name)
    entity_class_cache_node = entities.entities.get(entity_class_name, None)
    return entity_class_cache_node and (schema_cache_node.get("timestamp") == entity_class_cache_node.get("timestamp"))


def check_instance(_entity, _type):
    assert isinstance(_entity, _type), \
        "{e} should be type of {t}, but got {e_t}".format(e=_entity, t=_type, e_t=type(_entity))
