"""
The **cmdblib.client** module provides a Pythonic interface to the `CMDB REST
API <http://http://api.ops.elenet.me/?url=/api/cmdb/v1.yaml>`_, allowing your
programmatic access CMDB's resources. Some use cases can be found in
``tests/test_cmdblib.py``.

"""
from __future__ import unicode_literals

import logging
import time
import struct
import hashlib
import hmac
from collections import namedtuple
import urllib

import requests
import json as _json

from .schema import Schema
from .task import Task
from .entity import entity_class_factory, EntityFactory
from .schemas import SchemaCache

__author__ = "yuchen.huang"

LOG = logging.getLogger(__name__)

Request = namedtuple("Request", ["method", "url", "headers", "json"])


class Client(object):

    """A blocking http client.

    This client is provided as interface of this sdk. Most of the interaction
    with cmdb should be done with this client.

    :param client_id: id of current client, assigned by ``CMDB`` admin
    :type client_id: str
    :param secret: secret assigned by ``CMDB`` admin
    :type secret: str
    :param host: host of ``CMDB`` api server
    :type host: str
    :param port: port of `CMDB` api server
    :type port: interger

    Typical usage looks like this::

        client = Client(host="192.168.67.34",
                        port=8080,
                        client_id="client_id_for_auth",
                        secret="secret_for_auth")
        schemas = client.get_schemas(page=1, size=10)

    """

    def __init__(self, client_id, secret, host, port):
        self.host = host
        self.port = port
        self.client_id = client_id
        self.secret = secret
        self.docs = []

    @property
    def base_url(self):
        return ("http://" if not self.host.startswith("http") else "") +\
            self.host + ":" + str(self.port) + "/v1/"

    def schema_url(self, schema_name=None):
        return self.base_url + "schema/" + (schema_name and schema_name or
                                            "_list")

    def task_url(self, task_id=None):
        return self.base_url + "task/" + (task_id and task_id or "_list")

    def entity_url(self, schema_name, entity_key=None):
        return self.base_url + "entity/{schema_name}/".\
            format(schema_name=schema_name) +\
            (entity_key and entity_key or "_list")

    def get_schemas(self, page=1, size=10):
        """Get all schemas in cmdb by page. Schema is used to define the
         structure of some kind of resource like 'IP', 'PysicalHost', etc.

        :param page: the page number
        :param size: size of every page
        :type page: int
        :type size: int
        :rtype: a list of ``schema``


        Example::

            schemas = client.get_schemas(page=1, size=10)

        """
        url = self.schema_url() + "?page={page}&size={size}".format(
            page=page, size=size)
        r_json, _ = self.auth_requests(url, method="get")
        LOG.debug(r_json)
        return [Schema(schema) for schema in r_json["schemas"]]

    @SchemaCache
    def get_schema(self, schema_name):
        """Get one schema by the schema's name.

        :param schema_name: name of the schema
        :type schema_name: str
        :rtype: a ``schema`` based on the schema_name

        Example::

            test_schema = client.get_schema('test')

        """
        url = self.schema_url(schema_name)
        r_json, _ = self.auth_requests(url, method="get")
        return Schema(r_json)

    def save_schema(self, schema):
        """Save the ``schema`` to CMDB.

        :param schema: a ``schema`` object
        :type schema: Schema
        :rtype: (succedd: ``bool``, info: ``str``, task: ``Task``)

        Example::

            result, info = client.save_schema(my_modified_schema)
            # ``result`` should be ``True`` or ``False`` indicate if the
            # request is succesful or not.
        """
        assert isinstance(schema, Schema)
        url = self.schema_url(schema.name)
        # r = requests.post(url, json=schema.to_save_format())
        r_json, code = self.auth_requests(
            url, json=schema.to_save_format, method="post")
        if code < 300:
            return self.task_result(r_json.get("task_id"))
        else:
            return False, r_json, None

    def get_tasks(self, page=1, size=10, status=[]):
        """Get all ``tasks`` by page and size.

        Example::

            tasks = client.get_tasks(page=1, size=10)

        """
        if len(status) == 0:
            status = ['*']
        url = self.task_url() + "?page={page}&size={size}&status={status}".format(
            page=page, size=size, status=",".join(status))
        # r = requests.get(url)
        r_json, _ = self.auth_requests(url, method="get")
        return [Task(task) for task in r_json["tasks"]]

    def get_task(self, task_id):
        """Get one specific task by its ``task_id``.

        Example::

            my_task = client.get_task("my_task_id_return_by_other_request")

        """
        url = self.task_url(task_id)
        # r = requests.get(url)
        r_json, _ = self.auth_requests(url, method="get")
        return Task(r_json)

    def task_result(self, taskid):
        while True:
            task = self.get_task(taskid)
            if task.finished:
                return task.succeed, task.json, task
            time.sleep(0.2)

    def get_entities(self, schema, page=1, size=10):
        """Get all ``entities`` by itsq schema, page and size.

        :param schema: the ``schema`` of this type of ``entities``
        :type schema: str or Schema object
        :rtype: a list of ``entities``

        Example::

            test_entities = client.get_entities(test_schema, page=1, size=10)

            #or
            test_entities = client.get_entities("test_schema", page=1, size=10)

        """
        if not isinstance(schema, Schema):
            schema = self.get_schema(schema)
        assert isinstance(schema, Schema)
        url = self.base_url +\
            "entity/_search?" +\
            "q=_meta.schema={schema_name}&page={page}&size={size}".format(
                page=page, size=size, schema_name=schema.name)
        # r = requests.get(url)
        r_json, code = self.auth_requests(url, method="get")
        if len(r_json["entities"]) == 0:
            return []
        return [
            entity_class_factory(schema)(entity)
            for entity in r_json["entities"].get(schema.name, [])
        ]

    def get_entity(self, schema, entity_key):
        """Get one ``entity`` based on its schema and key

        :param schema: the ``schema`` of the type of the entity
        :type schema: str or ``Schema`` object
        :rtype: an entity object of the entity class based on the schema

        Example::

            test_entity = client.get_entity(test_schema, '123')

            #or
            test_entity = client.get_entity('test_schema', '123')

        """
        if not isinstance(schema, Schema):
            schema = self.get_schema(schema)
        assert isinstance(schema, Schema)
        r_json, _ = self.auth_requests(
            self.entity_url(schema.name, entity_key),
            method="get")
        return entity_class_factory(schema)(r_json)

    def save_entity(self, entity, async_task=False):
        """Save the modified or new created ``entity`` to CMDB.

        :param entity: an entity
        :type entity: ``entity.__class__``
        :rtype: (succedd: ``bool``, info: ``str``, task: ``Task``)

        Example::

            result, info, task = client.save_entity(my_entity)
            # ``result`` should be ``True`` or ``False`` indicate if the
            # request is succesful or not.

        """
        url = self.base_url + "entity/{schema_name}".format(
            schema_name=entity.__class__.__name__)
        # r = requests.post(url, json=entity.to_save_format())
        r_json, code = self.auth_requests(url, json=entity.to_save_format(),
                                          method="post")
        if r_json["code"] < 300:
            if async_task:
                return True, r_json, code
            return self.task_result(r_json["task_id"])
        else:
            return False, r_json, None

    def create_entity(self, schema):
        """Create a ``entity factory`` to build a new ``entity`` based on
         ``schema``.

        :param schema: the schema of which kind of entity you want to create
        :type schema: Schema
        :rtype: an ``entity`` object of the class based on the ``schema``

        Example::

            my_new_entity = client.create_entity('test_schema').set_id("asd").
                set_long("12345").build()
            another_entity = client.create_entity('test_schema').from_json(
            {
                'id': 'asdf',
                'long': '123456'
            })
            print(my_new_entity.id)
            # 'asd'
            print(another_entity.id)
            # 'asdf'
            print(my_new_entity.long)
            # '12345'
            result, task_info = client.save(my_new_entity)
            # Usually you dont need to check the task info of the ``save``
            # request if you have do some scaches and succeed.
            if result:
                task = client.get_task(task_info)
                while task.status == "processing":
                    task = client.get_task(task_info)
                succeed = task.status == "committed"

        """
        if not isinstance(schema, Schema):
            schema = self.get_schema(schema)

        def save(this_entity):
            self.save_entity(this_entity)
        return EntityFactory(schema, save)

    def search_entities(self, schema, page=1, size=10, **kwargs):
        """Search ``entities`` based on schema and conditions provided.

        Example::

            client = Client()
            some_schema = client.get_schema("some_schema_name")
            my_target_entities = client.search_entities(some_schema,
                id="my_entity_id", page=1, size=10)
            some_other_entities = client.search_entities(
                some_schema,
                some_field="field_value",
                another_field="another_field_value",
                page=2,
                size=5)

        """
        if not isinstance(schema, Schema):
            schema = self.get_schema(schema)
        q_list = [("_meta.schema", schema.name)] + list(kwargs.items())
        query = " AND ".join(["%s:%s" % (cond[0], str(cond[1]))
                              for cond in q_list])
        url = "{base}entity/_search?q={q}&page={page}&size={size}".format(
            base=self.base_url, q=query, page=page, size=size)
        r_json, code = self.auth_requests(url, method="get")
        return [
            entity_class_factory(schema)(entity)
            for entity in r_json["entities"].get(schema.name, [])
        ]

    def search_entities_by_query(self, query, page=1, size=10):
        """Search ``entities`` based on query

        Example::

            client = Client()
            some_app_entities = client.search_entities_by_query(
                "_type:app AND app_id:hearth*")

        """
        url = "{base}entity/_search?q={q}&page={page}&size={size}".format(
            base=self.base_url, q=query, page=page, size=size)
        r_json, code = self.auth_requests(url, method="get")
        entities = []
        for schemaName, _entities in r_json["entities"].items():
            schema = self.get_schema(schemaName)
            for e in _entities:
                entity = entity_class_factory(schema)(e)
                entities.append(entity)
        return entities

    @staticmethod
    def totp_gen(secret, time_range=30, i=0):
        tm = int(time.time() / time_range)
        b = struct.pack(str(">q"), tm + i)
        hm = hmac.HMAC(secret.encode("utf-8"), b, hashlib.sha1).digest()
        try:
            offset = hm[-1] & 0x0F
        except TypeError:
            offset = ord(hm[-1]) & 0x0F
        truncatedHash = hm[offset:offset + 4]
        code = struct.unpack(str(">L"), truncatedHash)[0]
        code &= 0x7FFFFFFF
        code %= 1000000
        return "%06d" % code

    def auth_requests(self, url, json=None, method="get"):
        """Send requests by url and method name

        Example::

            client.auth_requests(
                "http:192.168.67.34:8080/v1/entity/_search?q=*",
                json=None,
                method="get")

        """
        LOG.debug("{method} {url}".format(method=method, url=url))
        code_attempt = self.totp_gen(self.secret)
        headers = {
            "X-Authorization-Code": code_attempt,
            "X-Client-ID": self.client_id
        }
        if json:
            headers["Content-Type"] = "application/json"
        return self.fetch(method, url, headers, json)

    def async_fetch(self, method, url, headers, json=None):
        yield Request(method, url, headers, json)
        r_json, code = (yield)
        yield self.response_wrap(r_json, code)

    def fetch(self, method, url, headers, json=None):
        """overwrite this method if you need specific handling of the fetching
         process, like surport asynic request.

        :param method: request method in `get`, `post`, `patch` and `delete`
        :param url: the url for this request
        :param code_attempt: the authorization code, which need to be included in the head
        :param client_id: id of current client, which need to be include in the head
        :param json: the `json` body which will be included in the request
        :type json: dict

        """
        r = getattr(requests, method).__call__(
            url,
            data=json and _json.dumps(json) or {},
            headers=headers)
        LOG.debug(r)
        LOG.debug(r.text)
        return self.response_wrap(r, r.status_code)

    @staticmethod
    def response_wrap(r, code):
        if code == 401:
            raise UnAuthException(
                "Not Authorized. Plz use sufficient secrect code and client_id")
        if code == 403:
            raise ForbiddenException(
                "You don't have sufficient privileges to perform such action"
            )
        elif code > 299:
            raise RequestFailException(
                code,
                r.text,
                "Request Failed: {code} {info}".format(code=code, info=r.text))
        r_json = isinstance(r, dict) and r or r.json()
        return r_json, code


class UnAuthException(Exception):
    pass

class ForbiddenException(Exception):
    pass

class RequestFailException(Exception):

    def __init__(self, code, response, message):
        super(RequestFailException, self).__init__(message)
        self.code = code
        self.response = response
        self.message = message
