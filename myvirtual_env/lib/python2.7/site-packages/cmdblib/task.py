"""A ``task`` is used to execute the save or update requests from the client.

A ``task`` will have properties:
    * ``id`` is the identifier of this task.
    * ``task``
    * ``operator``
    * ``timestamp``
    * ``message``
    * ``status`` is one of ``proccessing``, ``accomplish``, ``failed``,``rollbacked`` or ``commited``.
    * ``effect``
"""
from __future__ import unicode_literals

import json
import logging
from pprint import pformat

__author__ = "yuchen.huang"

LOG = logging.getLogger(__name__)

ACCOMPLISH = "accomplish"
COMMITED = "committed"
FAILED = "failed"
ROLLBACKED = "rollbacked"


class Task(object):

    def __init__(self, json_task):
        try:
            self._id = json_task["id"]
            self._type = json_task["type"]
            self._task = json.loads(json_task["task"])
            self._operator = json_task["operator"]
            self._timestamp = json_task["timestamp"]
            self._message = json_task["message"]
            self._status = json_task["status"]
            self._effect = json_task["effect"]
            self.json = json_task
        except KeyError as e:
            LOG.error("Task can not read {property} from initialization.".
                      format(property=str(e)))
        self.check_is_task(self)

    def __repr__(self):
        return pformat(self.task)

    @property
    def id(self):
        return self._id

    @property
    def type(self):
        return self._type

    @property
    def task(self):
        return self._task

    @property
    def operator(self):
        return self._operator

    @property
    def timestamp(self):
        return self._timestamp

    @property
    def message(self):
        return self._message

    @property
    def status(self):
        return self._status

    @property
    def effect(self):
        return self._effect

    @property
    def finished(self):
        return self.status in [ACCOMPLISH, COMMITED, FAILED, ROLLBACKED]

    @property
    def succeed(self):
        return self.status in [ACCOMPLISH, COMMITED]

    @property
    def failed(self):
        return self.status in [ROLLBACKED, FAILED]

    @staticmethod
    def check_is_task(task):
        # assert isinstance(task, Task)
        # assert isinstance(task.id, str)
        # assert task.type in ["entity", "schema"]
        # assert isinstance(task.task, str)
        # assert isinstance(task.operator, (str, type(None)))
        # assert isinstance(task.timestamp, int)
        # assert isinstance(task.message, (str, type(None)))
        # assert isinstance(task.status, (str, int))
        # assert isinstance(task.effect, (str, type(None)))
        return
